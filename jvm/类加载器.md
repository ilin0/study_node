### 类加载器.md

#### 双亲委托机制 
    各个加载器按照父子关系形成了树形结构。
    除了根类加载器之外，其余类加载器都有且只有一个父加载器。

    定义类加载器即真正加载类的加载器，
    初始类加载器即能成功返回Class对象的引用的加载器（包括定义类加载器）。

    加载器加载的路径
    1、System.getProperty("sun.boot.class.path");
    2、System.getProperty("java.ext.dirs");
    3、System.getProperty("java.class.path");

#### 总结
    类加载器双亲委托的好处
1. 可以确保java核心库类型安全；所有的java应用都至少会引用java.lang.Object类，也就是说；在运行期java.lang.Object会被加载java虚拟机中；如果这个加载过程中由java应用自己的类所加载完成，那么很可能就会在jvm中存在多个版本的java.lang.Object类，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）。借助于双亲委托机制，java核心类库中的加载工作都是由启动（根）类加载器加载。从而确保java应用所使用的都是同一个版本的java核心类库，它们之间是相互兼容的。
2. java核心类库所提供的类不会被java应用所提供的类所替换。
3. 不同的类加载器可以为相同的名称的类创建额外的命名空间，相同名称的类可以并存在在java虚拟机中，只需要用不同的类加载器来加载即可（不构成父子关系）。不同类加载器所加载的类之间是不兼容的，这就相当于在java虚拟机内部创建了一个又一个相互隔离的java类空间，这类技术在多框架中得到了实际应用。

#### 系统类加载器与扩展类加载器是由谁加载？
    内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，它就是启动类加载器（Bootstrap）。
    启动类加载器并不是java类，而其它的加载器则都是java类，启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。

    所有类加载器（除了启动类加载器）都被实现为java类。不过，总归要有一个组件来加载第一个java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯java类加载器就是启动类加载器的职责。

    启动类加载器还会负责加载供jre正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。

#### 系统类加载器
    java.system.class.loader
    如果该属性未设置时，AppClassLoader就是系统类加载器