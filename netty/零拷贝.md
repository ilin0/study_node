### 零拷贝.md
    场景，磁盘 文件 读取  内存（字节数组） 发送 用户（流）

    操作系统内发生了什么？
    分为二步1：读，2：写
    一、 读
    1、用户空间 -》内核空间 发送 读取系统调用请求，
    2、内核空间真正 -》 磁盘 发出读取数据请求   数据被读取内核空间的缓冲区中（DMA）方式（用户空间是无法用的），再把它从内核空间缓冲区中的数据拷贝到用户空间缓冲区中（二次拷贝操作）。
    二、写
    1、用户空间 -》内核空间 发送 写的系统调用请求，这时将读到用户空间的数据再次拷贝到内核空间中，这时才能将数据写到网络中或者磁盘中。

    读的时候将数据从内核空间拷贝到用户空间，写的时候再次拷贝到内存空间，这二步的操作是没有任何意义的。高并发时是很影响性能的。
    如下图：

![image](https://github.com/ilin0/study_node/raw/master/netty/image/netty2018030201.png)

    零拷贝：用户空间的二次拷贝是要依赖操作系统的支持。下图零拷贝与上图的区别。
![image](https://github.com/ilin0/study_node/raw/master/netty/image/netty2018030202.png)

    这种还不是理想状态，它还是有一次在内核空间中的拷贝操作。

    为什么会出现在内核空间中还有一次拷贝的操作呢？
    因为对于一般硬件来说，直接内存访问机制希望它的内存地址是连续的，buffer也是支持这种的。
![image](https://github.com/ilin0/study_node/raw/master/netty/image/netty2018030203.png)

#### 存在的一些问题
    但在内核空间出现了一问题，用户是不知道的，它对于用户空间来说就是一个墨盒。我们想要操作它是不可以的。我们可以通过内存映射来操作改变它。（对于这种操作的性能、效率好不好，还要进行系统测试）